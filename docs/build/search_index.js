var documenterSearchIndex = {"docs":
[{"location":"#MiniMods","page":"MiniMods","title":"MiniMods","text":"","category":"section"},{"location":"","page":"MiniMods","title":"MiniMods","text":"Extension of the Mods  package for very small moduli.  ","category":"page"},{"location":"#Everything-is-the-same,-just-smaller","page":"MiniMods","title":"Everything is the same, just smaller","text":"","category":"section"},{"location":"","page":"MiniMods","title":"MiniMods","text":"The MiniMods module defines the MiniMod type that behaves exactly the same as Mod (from the Mods module) except that  moduli are restricted to lie between 2 and 255. In this way, a MiniMod only takes up one byte of memory, whereas a Mod uses  eight. ","category":"page"},{"location":"","page":"MiniMods","title":"MiniMods","text":"julia> using MiniMods\n\njulia> a = MiniMod{17}(-2)\nMiniMod{17}(15)\n\njulia> inv(a)\nMiniMod{17}(8)\n\njulia> 2a-5\nMiniMod{17}(8)\n\njulia> b = MiniMod{1000}(-1)\nERROR: AssertionError: modulus is too large","category":"page"},{"location":"#Full-interoperability-with-Mods","page":"MiniMods","title":"Full interoperability with Mods","text":"","category":"section"},{"location":"","page":"MiniMods","title":"MiniMods","text":"While it is not clear why one would like to mix expressions with both Mod and  MiniMod types, this is permitted so long as the moduli of the numbers are the same. The result of such a mixed expression is MiniMod because this is the more  space efficient type. ","category":"page"},{"location":"","page":"MiniMods","title":"MiniMods","text":"julia> using Mods \n\njulia> a = MiniMod{10}(6);\n\njulia> b = Mod{10}(5);\n\njulia> a+b\nMiniMod{10}(1)\n\njulia> sizeof(a)\n1\n\njulia> sizeof(b)\n8","category":"page"},{"location":"#Other-packages","page":"MiniMods","title":"Other packages","text":"","category":"section"},{"location":"","page":"MiniMods","title":"MiniMods","text":"We have tested using MiniMods with LinearAlgebra, LinearAlgebraX, and SimplePolynomials. It appears to work well in those settings.","category":"page"},{"location":"","page":"MiniMods","title":"MiniMods","text":"julia> using LinearAlgebra, LinearAlgebraX\n\njulia> A = rand(MiniMod{11},5,5)\n5Ã—5 Matrix{MiniMod{11}}:\n MiniMod{11}(4)  MiniMod{11}(2)  MiniMod{11}(0)  MiniMod{11}(6)  MiniMod{11}(1)\n MiniMod{11}(4)  MiniMod{11}(5)  MiniMod{11}(1)  MiniMod{11}(3)  MiniMod{11}(6)\n MiniMod{11}(9)  MiniMod{11}(7)  MiniMod{11}(2)  MiniMod{11}(9)  MiniMod{11}(9)\n MiniMod{11}(1)  MiniMod{11}(9)  MiniMod{11}(7)  MiniMod{11}(0)  MiniMod{11}(5)\n MiniMod{11}(5)  MiniMod{11}(7)  MiniMod{11}(5)  MiniMod{11}(2)  MiniMod{11}(8)\n\njulia> det(A)\nMiniMod{11}(7)\n\njulia> detx(A)\nMiniMod{11}(7)\n\njulia> rankx(A)\n5\n\njulia> sizeof(A)   # 5x5 matrix of MiniMods using 25 bytes\n25\n\njulia> sizeof(Mod.(A)) # but same matrix of Mods using 8 times as much\n200\n\njulia> using SimplePolynomials\n\njulia> x = getx()\nx\n\njulia> p = one(MiniMod{2}) + x\nMiniMod{2}(1) + MiniMod{2}(1)*x\n\njulia> p^8\nMiniMod{2}(1) + MiniMod{2}(1)*x^8","category":"page"},{"location":"#MiniMod-numbers-are-smaller-but-not-faster-than-Mod-numbers","page":"MiniMods","title":"MiniMod numbers are smaller but not faster than Mod numbers","text":"","category":"section"},{"location":"","page":"MiniMods","title":"MiniMods","text":"julia> using MiniMods, Mods, LinearAlgebra, BenchmarkTools\n\njulia> m = 251; d = 500;\n\njulia> A = rand(Mod{m}, d, d);\n\njulia> B = MiniMod.(A);\n\njulia> @btime A*A;\n  601.262 ms (6 allocations: 1.94 MiB)\n\njulia> @btime B*B;\n  682.364 ms (6 allocations: 275.75 KiB)\n\njulia> @btime det(A)\n  150.941 ms (4 allocations: 1.91 MiB)\nMod{251}(217)\n\njulia> @btime det(B)\n  176.047 ms (4 allocations: 248.31 KiB)\nMiniMod{251}(217)","category":"page"},{"location":"#Larger-moduli","page":"MiniMods","title":"Larger moduli","text":"","category":"section"},{"location":"","page":"MiniMods","title":"MiniMods","text":"We envision that users of this module will be primarily using very small  moduli, so the upper bound of 255 won't (we hope) be a problem. However, users may elect to modify the code to work with larger integers (but smaller than Int). ","category":"page"},{"location":"","page":"MiniMods","title":"MiniMods","text":"In the source file MiniMods.jl find the line","category":"page"},{"location":"","page":"MiniMods","title":"MiniMods","text":"const SmallInt = UInt8","category":"page"},{"location":"","page":"MiniMods","title":"MiniMods","text":"and change UInt8 to another integer type. For example, use UInt16 to expand the range of moduli to 65535.","category":"page"}]
}
